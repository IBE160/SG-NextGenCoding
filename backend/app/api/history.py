# backend/app/api/history.py
"""
History API endpoints for retrieving user's past summaries and quizzes.
"""

import logging
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import select
from gotrue.types import User

from app.db.session import get_session
from app.db.models import Document, Summary, Quiz, Question, UserAnswer
from app.dependencies import get_current_user
from app.schemas.history import (
    SummaryHistoryItem,
    QuizHistoryItem,
    SummaryHistoryResponse,
    QuizHistoryResponse,
    CombinedHistoryItem,
    CombinedHistoryResponse,
    HistoryItemType,
    QuestionReviewItem,
    QuizReviewDetail,
    QuizReviewResponse,
)

router = APIRouter()

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def truncate_text(text: str, max_length: int = 200) -> str:
    """Truncate text to max_length characters, adding ellipsis if needed."""
    if len(text) <= max_length:
        return text
    return text[:max_length].rstrip() + "..."


@router.get(
    "/history/summaries",
    response_model=SummaryHistoryResponse,
    status_code=status.HTTP_200_OK,
    summary="Get user's summary history",
    description="Retrieves a chronological list of summaries generated by the authenticated user."
)
async def get_summary_history(
    session: AsyncSession = Depends(get_session),
    current_user: Optional[User] = Depends(get_current_user),
    limit: int = 50,
    offset: int = 0,
):
    """
    Retrieve all summaries for the authenticated user in chronological order (newest first).
    
    - **limit**: Maximum number of summaries to return (default: 50)
    - **offset**: Number of summaries to skip for pagination (default: 0)
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required to view history"
        )
    
    user_id = UUID(current_user.id)
    logger.info(f"Fetching summary history for user: {user_id}")
    
    try:
        # Query summaries with document join for document title
        query = (
            select(Summary, Document)
            .join(Document, Summary.document_id == Document.id)
            .where(Summary.user_id == user_id)
            .order_by(Summary.generated_at.desc())
            .offset(offset)
            .limit(limit)
        )
        
        result = await session.execute(query)
        rows = result.all()
        
        # Count total summaries for pagination
        count_query = select(Summary).where(Summary.user_id == user_id)
        count_result = await session.execute(count_query)
        total = len(count_result.all())
        
        # Transform to response model
        history_items: List[SummaryHistoryItem] = []
        for summary, document in rows:
            history_items.append(
                SummaryHistoryItem(
                    id=summary.id,
                    document_id=summary.document_id,
                    document_title=document.filename,
                    summary_preview=truncate_text(summary.summary_text) if summary.summary_text else None,
                    generated_at=summary.generated_at,
                    ai_model=summary.ai_model,
                    type=HistoryItemType.SUMMARY,
                )
            )
        
        logger.info(f"Retrieved {len(history_items)} summaries for user: {user_id}")
        
        return SummaryHistoryResponse(
            data=history_items,
            total=total,
            message=f"Retrieved {len(history_items)} summaries"
        )
        
    except Exception as e:
        logger.error(f"Error fetching summary history for user {user_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve summary history"
        )


@router.get(
    "/history/quizzes",
    response_model=QuizHistoryResponse,
    status_code=status.HTTP_200_OK,
    summary="Get user's quiz history",
    description="Retrieves a chronological list of quizzes generated by the authenticated user."
)
async def get_quiz_history(
    session: AsyncSession = Depends(get_session),
    current_user: Optional[User] = Depends(get_current_user),
    limit: int = 50,
    offset: int = 0,
):
    """
    Retrieve all quizzes for the authenticated user in chronological order (newest first).
    
    - **limit**: Maximum number of quizzes to return (default: 50)
    - **offset**: Number of quizzes to skip for pagination (default: 0)
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required to view history"
        )
    
    user_id = UUID(current_user.id)
    logger.info(f"Fetching quiz history for user: {user_id}")
    
    try:
        # Query quizzes with document join for document title
        query = (
            select(Quiz, Document)
            .join(Document, Quiz.document_id == Document.id)
            .where(Quiz.user_id == user_id)
            .order_by(Quiz.created_at.desc())
            .offset(offset)
            .limit(limit)
        )
        
        result = await session.execute(query)
        rows = result.all()
        
        # Count total quizzes for pagination
        count_query = select(Quiz).where(Quiz.user_id == user_id)
        count_result = await session.execute(count_query)
        total = len(count_result.all())
        
        # Transform to response model
        history_items: List[QuizHistoryItem] = []
        for quiz, document in rows:
            history_items.append(
                QuizHistoryItem(
                    id=quiz.id,
                    document_id=quiz.document_id,
                    document_title=document.filename,
                    title=quiz.title,
                    status=quiz.status,
                    total_questions=quiz.total_questions,
                    created_at=quiz.created_at,
                    ai_model=quiz.ai_model,
                    type=HistoryItemType.QUIZ,
                )
            )
        
        logger.info(f"Retrieved {len(history_items)} quizzes for user: {user_id}")
        
        return QuizHistoryResponse(
            data=history_items,
            total=total,
            message=f"Retrieved {len(history_items)} quizzes"
        )
        
    except Exception as e:
        logger.error(f"Error fetching quiz history for user {user_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve quiz history"
        )


@router.get(
    "/history",
    response_model=CombinedHistoryResponse,
    status_code=status.HTTP_200_OK,
    summary="Get user's combined history",
    description="Retrieves a chronological list of all summaries and quizzes generated by the authenticated user."
)
async def get_combined_history(
    session: AsyncSession = Depends(get_session),
    current_user: Optional[User] = Depends(get_current_user),
    limit: int = 50,
    offset: int = 0,
):
    """
    Retrieve all summaries and quizzes for the authenticated user in chronological order (newest first).
    Items are combined and sorted by creation date.
    
    - **limit**: Maximum number of items to return (default: 50)
    - **offset**: Number of items to skip for pagination (default: 0)
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required to view history"
        )
    
    user_id = UUID(current_user.id)
    logger.info(f"Fetching combined history for user: {user_id}")
    
    try:
        # Fetch summaries
        summary_query = (
            select(Summary, Document)
            .join(Document, Summary.document_id == Document.id)
            .where(Summary.user_id == user_id)
        )
        summary_result = await session.execute(summary_query)
        summary_rows = summary_result.all()
        
        # Fetch quizzes
        quiz_query = (
            select(Quiz, Document)
            .join(Document, Quiz.document_id == Document.id)
            .where(Quiz.user_id == user_id)
        )
        quiz_result = await session.execute(quiz_query)
        quiz_rows = quiz_result.all()
        
        # Combine and transform items
        combined_items: List[CombinedHistoryItem] = []
        
        for summary, document in summary_rows:
            combined_items.append(
                CombinedHistoryItem(
                    id=summary.id,
                    document_id=summary.document_id,
                    document_title=document.filename,
                    title=None,
                    preview=truncate_text(summary.summary_text) if summary.summary_text else None,
                    type=HistoryItemType.SUMMARY,
                    status=None,
                    total_questions=None,
                    created_at=summary.generated_at,
                    ai_model=summary.ai_model,
                )
            )
        
        for quiz, document in quiz_rows:
            combined_items.append(
                CombinedHistoryItem(
                    id=quiz.id,
                    document_id=quiz.document_id,
                    document_title=document.filename,
                    title=quiz.title,
                    preview=None,
                    type=HistoryItemType.QUIZ,
                    status=quiz.status,
                    total_questions=quiz.total_questions,
                    created_at=quiz.created_at,
                    ai_model=quiz.ai_model,
                )
            )
        
        # Sort by created_at descending
        combined_items.sort(key=lambda x: x.created_at, reverse=True)
        
        total = len(combined_items)
        
        # Apply pagination
        paginated_items = combined_items[offset:offset + limit]
        
        logger.info(f"Retrieved {len(paginated_items)} combined history items for user: {user_id}")
        
        return CombinedHistoryResponse(
            data=paginated_items,
            total=total,
            message=f"Retrieved {len(paginated_items)} history items"
        )
        
    except Exception as e:
        logger.error(f"Error fetching combined history for user {user_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve history"
        )


@router.get(
    "/history/quizzes/{quiz_id}",
    response_model=QuizReviewResponse,
    status_code=status.HTTP_200_OK,
    summary="Get detailed quiz review with user's answers",
    description="Retrieves detailed quiz results including all questions, user's answers, and correct answers."
)
async def get_quiz_review(
    quiz_id: UUID,
    session: AsyncSession = Depends(get_session),
    current_user: Optional[User] = Depends(get_current_user),
):
    """
    Retrieve detailed quiz review for a specific quiz.
    
    Returns the quiz with all questions, the user's submitted answers,
    correct answers, and score calculation.
    
    - **quiz_id**: The UUID of the quiz to review
    """
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required to view quiz review"
        )
    
    user_id = UUID(current_user.id)
    logger.info(f"Fetching quiz review for quiz {quiz_id} by user {user_id}")
    
    try:
        # Query quiz with document join
        quiz_query = (
            select(Quiz, Document)
            .join(Document, Quiz.document_id == Document.id)
            .where(Quiz.id == quiz_id)
        )
        quiz_result = await session.execute(quiz_query)
        quiz_row = quiz_result.first()
        
        if not quiz_row:
            logger.warning(f"Quiz {quiz_id} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Quiz not found"
            )
        
        quiz, document = quiz_row
        
        # Check if user owns this quiz
        if quiz.user_id != user_id:
            logger.warning(f"User {user_id} attempted to access quiz {quiz_id} owned by {quiz.user_id}")
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You don't have permission to view this quiz"
            )
        
        # Query questions for this quiz
        questions_query = (
            select(Question)
            .where(Question.quiz_id == quiz_id)
            .order_by(Question.order_index)
        )
        questions_result = await session.execute(questions_query)
        questions = questions_result.scalars().all()
        
        # Query user answers for this quiz
        answers_query = (
            select(UserAnswer)
            .where(UserAnswer.quiz_id == quiz_id)
            .where(UserAnswer.user_id == user_id)
        )
        answers_result = await session.execute(answers_query)
        user_answers = answers_result.scalars().all()
        
        # Create a map of question_id -> user_answer
        answer_map = {answer.question_id: answer for answer in user_answers}
        
        # Build question review items
        question_items: List[QuestionReviewItem] = []
        correct_count = 0
        
        for question in questions:
            user_answer = answer_map.get(question.id)
            
            # Parse options from JSON string if present
            options = None
            if question.options:
                import json
                try:
                    options = json.loads(question.options)
                except json.JSONDecodeError:
                    options = None
            
            is_correct = user_answer.is_correct if user_answer else None
            if is_correct:
                correct_count += 1
            
            question_items.append(
                QuestionReviewItem(
                    id=question.id,
                    question_text=question.question_text,
                    question_type=question.question_type,
                    options=options,
                    correct_answer=question.correct_answer,
                    explanation=question.explanation,
                    user_answer=user_answer.user_answer if user_answer else None,
                    is_correct=is_correct,
                    order_index=question.order_index,
                )
            )
        
        # Calculate score percentage
        total_questions = len(questions)
        score_percentage = (correct_count / total_questions * 100) if total_questions > 0 else 0.0
        
        # Build the response
        quiz_detail = QuizReviewDetail(
            id=quiz.id,
            document_id=quiz.document_id,
            document_title=document.filename,
            title=quiz.title,
            status=quiz.status,
            total_questions=total_questions,
            score=correct_count,
            score_percentage=round(score_percentage, 1),
            ai_model=quiz.ai_model,
            created_at=quiz.created_at,
            questions=question_items,
        )
        
        logger.info(f"Retrieved quiz review for quiz {quiz_id}: {correct_count}/{total_questions} correct")
        
        return QuizReviewResponse(
            data=quiz_detail,
            message=f"Quiz review retrieved: {correct_count}/{total_questions} correct ({round(score_percentage, 1)}%)"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching quiz review for quiz {quiz_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve quiz review"
        )
